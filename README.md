# cpp-work
用于学习cpp代码
## 类型 内存
#### C++提供了大量的整型,应使用哪种类型呢?
通常, int被设置为对目标计算机而言最为“自然”的长度。
**自然长度(natural size)指的是计算机处理起来效率最高的长度。**如果没有非常有说服力的理由来选择其他类型，则应使用int。
现在来看看可能使用其他类型的原因。如果变量表示的值不可能为负，如文档中的字数,则可以使用无符号类型,这样变量可以表示更大的值。
如果知道变量可能表示的整数值大于16位整数的最大可能值,则使用1ong。即使系统上int为32位,也应这样做。这样,将程序移植到16位系统时,
就不会突然无法正常工作（参见图3.2）。如果要存储的值超过20亿，可使用long long。

#### 内存节省主要是数组这种连续内存结构的数据
如果short比int小,则使用short可以节省内存。通常,仅当有大型整型数组时,才有必要使用short。(数组是一种数据结构,在内存中连续存储同
类型的多个值。)如果节省内存很重要,则应使用short而不是使用int,即使它们的长度是一样的。例如,假设要将程序从int为16位的系统移到int
为32位的系统,则用于存储int数组的内存量将加倍,但short数组不受影响。请记住,节省一点就是赢得一点。


#### 数据的使用说明
C++将整型常量存储为int类型。首先来看看后缀。后缀是放在数字常量后面的字母,用于表示类型。整数后面的1或L后缀表示该整数为long常量, u或U后缀表示unsigned int常量, ul (可以采用任何一种顺序,大写小写均可)表示unsigned long常量(由于小写1看上去像1,因此应使用大写L作后缀)。例如，在int为16位、long为32位的系统上，数字22022被存储为int，占16位，数字22022L被存储为long，占32位。同样，22022LU和22022UL都被存储为unsigned long。 C++11提供了用于表示类型long long的后缀ll和LL,还提供了用于表示类型unsigned long long的后缀ull、Ull、uLL和ULL.接下来考察长度。在C++中，对十进制整数采用的规则，与十六进制和八进制稍微有些不同。对于不带后缀的十进制整数,将使用下面几种类型中能够存储该数的最小类型来表示: int、long或long long。在int为16位、long为32位的计算机系统上, 20000被表示为int类型, 40000被表示为long类型, 3000000000被表示为long long类型。对于不带后缀的十六进制或八进制整数,将使用下面几种类型中能够存储该数的最小类型来表示: int、 unsigned int long、 unsigned long、 long long或unsigned long long。在将40000表示为long的计算机系统中，十六进制数0x9C40 (40000)将被表示为unsigned int。这是因为十六进制常用来表示内存地址,而内存地址是没有符号的,因此, usigned int比long更适合用来表示16位的地址。



#### 数据存储的实质

有趣的是，程序中输入的是M，而不是对应的字符编码77。另外，程序将打印M，而不是77。通过查看内存可以知道, 77是存储在变量ch中的值。这种神奇的力量不是来自char类型,而是来自cin和cout,这些工具为您完成了转换工作。输入时, cin将键盘输入的M转换为77;输出时, cout将值77转换为所显示的字符M; cin和cout的行为都是由变量类型引导的。如果将77存储在int变量中,则cout将把它显示为77 (也就是说, cout显示两个字符7) 。程序清单3.6说明了这一点,该程序还演示了如何在C++中书写字符字面值:将字符用单引号括起,如'M' (注意,示例中没有使用双引号。C++对字符用单引号，对字符串使用双引号。cout对象能够处理这两种情况,但正如第4章将讨论的,这两者有天壤之别) 。最后,程序引入了cout的一项特性—cout. put()函数，该函数显示一个字符。





#### 数据类型提升下面是C++11版本的校验表,编译器将依次查阅该列表。

(1)如果有一个操作数的类型是long double,则将另一个操作数转换为long double。

(2)否则,如果有一个操作数的类型是double,则将另一个操作数转换为double.

(3)否则,如果有一个操作数的类型是float,则将另一个操作数转换为float。

(4)否则,说明操作数都是整型,因此执行整型提升。

(5)在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低,则转换为级别高的类型。

(6)如果一个操作数为有符号的,另一个操作数为无符号的,且无符号操作数的级别比有符号操作数高,则将有符号操作数转换为无符号操作数所属的类型。

(7)否则,如果有符号类型可表示无符号类型的所有可能取值,则将无符号操作数转换为有符号操作数所属的类型。

(8)否则，将两个操作数都转换为有符号类型的无符号版本。ANSI C遵循的规则与ISO 2003 C++相同,这与前述规则稍有不同;而传统K&R C的规则又与ANSI C稍有不同。例如，传统C语言总是将float提升为double，即使两个操作数都是float。

前面的列表谈到了整型级别的概念。简单地说,有符号整型按级别从高到低依次为1ong long、long、 int、 short和signed char。无符号整型的排列顺序与有符号整型相同。类型char、 signed char和unsigned char的级别相同。类型bool的级别最低。wchar_t、char16_t和char32_t的级别与其底层类型相同。



#### 传递参数时的转换
正如第7章将介绍的，传递参数时的类型转换通常由C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short类型（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。



这里有两点需要说明。首先，string类定义了一种char *到string的转换功能，这使得可以使用C-风格字符串来初始化string对象。其次是本章前面讨论过的类型为const引用的形参的一个属性。假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。例如，在本章前面，将int实参传递给const double &形参时，就是以这种方式进行处理的。同样，也可以将实参char *或const char *传递给形参const string &。



#### 参数使用指针，引用，还是值传递？

使用引用参数的主要原因有两个。

1. 程序员能够修改调用函数中的数据对象。
2. 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些指导原则：

1. 对于使用传递的值而不作修改的函数。
2. 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
3. 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
4. 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
5. 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。
6. 如果数据对象是数组，则只能使用指针。
7. 如果数据对象是结构，则使用引用或指针。
8. 如果数据对象是类对象，则使用引用。



#### 强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。（C++认识到，必须有类型





#### 指针地址

![image-20231109181815368](D:\cpp_work\mdImg\image-20231109181815368.png)

```c++
double *varAddress = &bChar;  //note: 必须以对应的类型来声明 *varAddress的类型，因为*varAddress指的是 double类型的值  varAddress指的是一个变量的地址 

cout << "*varAddress " << *varAddress << endl; // 值
cout << "varAddress " << varAddress << endl; // 地址
```

顺便说一句, *运算符两边的空格是可选的。

传统上,C程序员使用这种格式：

```
int *ptr;
```

这强调\*ptr是一个int类型的值。

而很多C++程序员使用这种格式：

```
int* ptr;
```

这强调的是：int\*是一种类型一指向int的指针。在哪里添加空格对于编译器来说没有任何区别，

您甚至可以这样做：

```
int*ptr;
```

但要知道的是，下面的声明创建一个指针（p1）和一个int变量（p2）：

```
int* p1, p2;
```

对每个指针变量名，都需要使用一个。

![image-20231116173907464](D:\cpp_work\mdImg\image-20231116173907464.png)



**对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。第9章将更详细地讨论这一点。**



##### 数组的指针



**int( * pArrAYInt)[6] = &arrInt; // arrInt是一个int数组**

arrInt 可以看成是数组的第一个元素的地址

arrInt[1]  == *(arrInt + 1)  // 访问第二个元素的值，其实执行的操作是等价的

现在来看一看数组表达式stacks[1]。C++编译器将该表达式看作是*（stacks + 1），这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。最后的结果便是stacks [1]的含义（运算符优先级要求使用括号，如果不使用括号，将给*stacks加1，而不是给stacks加1）。
从该程序的输出可知，*（stacks + 1）和stacks[1]是等价的。同样，*（stacks + 2）和stacks[2]也是等价的。

如果使用的是指针，而不是数组名，则C++也将执行同样的转换

```
arrayname[i] becomes *(arrayname + i)
```

在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。

字符串字面值是常量，这就是为什么代码在声明中使用关键字const的原因。



二维数组：

```
ar2 [r] [c]== * (* (ar2 + r) + c)     // same thing
```

```
** &pa == *pa == pa [0] // pa 是一个数组
```

**由于C++将“taco”解释为第一个元素的地址，因此它将“taco”[2]解释为第二个元素的值，即字符c。换句话来说，字符串常量的行为与数组名相同。**



#### 引用变量

```
int rats = 101;

int & rodents = rats;

int * prats = &rats;
```

达式rodents和*prats都可以同rats互换，而表达式&rodents和prats都可以同&rats互换。从这一点来说，引用看上去很像伪装表示的指针（其中，*解除引用运算符被隐式理解）。除了表示法不同外，还有其他的差别。例如，差别之一是，必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值：

------



##### 生成临时变量

如果引用参数是const，则编译器将在下面两种情况下生成临时变量：
实参的类型正确，但不是左值；
实参的类型不正确，但可以转换为正确的类型。
左值是什么呢？左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式。

##### 右值引用

C++11新增了另一种引用——右值引用（rvalue reference）。这种引用可指向右值，是使用&&声明的：

```
double && rref = std::sgrt(36.00); // not allowed for double &
double j = 15.0;
double && jref = 2.0* j + 18.5;// not allowed for double &
std::cout << rref << '\n';// display 6.0
std::cout << jref << \n';// display 48.5;
```

#### 返回值为引用的好处

如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到dup，其效率更高。



##### 返回引用时需要注意的问题

返回引用时最重要的一点是，**应避免返回函数终止时不再存在的内存单元引用**。您应避免编写下面这样的代码：

```c++
const free_throws & clone2 (free_throws & ft)
{
	free_throws newguy;//first step to big error
	newguy = ft;// copy info
	return newguy; //return reference to copy
}
```



#### 函数模板

//template <class AnyType01> // 函数模板，用于参数的自动分配类型，可以传入多类型的参数提供同一种逻辑
template <typename AnyType> // 函数模板，用于参数的自动分配类型，可以传入多类型的参数提供同一种逻辑



#### 头文件中常包含的内容

请不要将函数定义或变量声明放到头文件中。这样做对于简单的情况可能是可行的，但通常会引来麻烦。例如，如果在头文件包含一个函数定义，然后在其他两个文件（属于同一个程序）中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则这将出错。下面列出了头文件中常包含的内容。

1. 函数原型。
2. 使用#define或const定义的符号常量。
3. 结构声明。
4. 类声明。
5. 模板声明。
6. 内联函数。



##### 注意

，在包含头文件时，我们使用“coordin.h”，而不是<coodin.h>。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）。如果没有在那里找到头文件，则将在标准位置查找。**因此在包含自己的头文件时，应使用引号而不是尖括号。**

##### 警告：

在IDE中，不要将头文件加入到项目列表中，也不要在源代码文件中使用#include来包含其他源代码文件。



![image-20231123143927632](D:\PrivateData\document\md图片资源\image-20231123143927632.png)





拒绝多次包含头文件： 多次包含编译时也可能报错

#ifndef CustomCommon
#define CustomCommon

#endif // CustomCommon

在不同的头文件使用不同的宏定义即可减少该错误的出现，比如说改该头文件被其他头文件引用，或者已经被源文件引用



#### 数据保留在内存中的时间

C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于**数据保留在内存中的时间。**

1. 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。
2. 静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。
3. 线程存储持续性（C++11）：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。
4. 动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。



#### 作用域和链接

**作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。**例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。

**C++变量的作用域有多种。作用域为局部的变量只在定义它的代码块中可用。代码块是由花括号括起的一系列语句**。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。**作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用**。自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用（这就是为什么这些名称是什么以及是否出现都不重要的原因）。在类中声明的成员的作用域为整个类（参见第10章）。**在名称空间中声明的变量的作用域为整个名称空间（由于名称空间已经引入到C++语言中，因此全局作用域是名称空间作用域的特例）。**



在函数中 声明一个块级作用域中声明和函数中声明同名的一个变量他们的作用域时机和范围

![image-20231123162035641](D:\PrivateData\document\md图片资源\image-20231123162035641.png)



函数调用数据栈

![image-20231123162814002](D:\PrivateData\document\md图片资源\image-20231123162814002.png)

#### 关键字

下面是存储说明符：
auto（在C++11中不再是说明符）；
register；
static；
extern；
thread_local（C++11新增的）；
mutable。

cv限定符：
const；
volatile。



const veep 是一个结构常量

veep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符使得access不受这种限制。

本书不使用volatile或mutable，但将进一步介绍const。



其中的大部分已经介绍过了，在同一个声明中不能使用多个说明符，但thread_local除外，它可与static或extern结合使用。前面讲过，在C++11之前，可以在声明中使用关键字auto指出变量为自动变量；但在C++11中，auto用于自动类型推断。关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的。关键字static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。关键字extern表明是引用声明，即声明引用在其他地方定义的变量。关键字thread_local指出变量的持续性与其所属线程的持续性相同。**thread_local变量之于线程，犹如常规静态变量之于整个程序。关键字mutable的含义将根据const来解释，因此先来介绍cv-限定符，然后再解释它。**



##### 静态持续变量

和C语言一样，C++也为静态存储持续性变量提供了3种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。

![image-20231123163609311](D:\PrivateData\document\md图片资源\image-20231123163609311.png)

正如前面指出的，所有静态持续变量（上述示例中的global、one_file和count）在整个程序执行期间都存在。在funct1( )中声明的变量count的作用域为局部，没有链接性，**这意味着只能在funct1( )函数中使用它，就像自动变量llama一样。然而，与llama不同的是，即使在funct1( )函数没有被执行时，count也留在内存中**.

由于one_file的链接性为内部，因此只能在包含上述代码的文件中使用它；由于global的链接性为外部，因此可以在程序的其他文件中使用它。



##### 再谈const

在C++（但不是在C语言）中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在C++看来，全局const定义（如下述代码段所示）就像使用了static说明符一样。



**C++修改了常量类型的规则，让程序员更轻松。例如，假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件**。那么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都将包含类似下面这样的定义



> 头文件中定义 const 常量 == 在一个源文件里面使用 const常量 并初始化，其他源文件中使用extern 声明 const 变量 那么使用的也是同一个const变量



在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。**这与常规外部变量不同，定义常规外部变量时，不必使用extern关键字，但在使用该变量的其他文件中必须使用extern。**然而，请记住，鉴于单个const在多个文件之间共享，**因此只有一个文件可对其进行初始化。**
在函数或代码块中声明const时，其作用域为代码块，即仅当程序执行该代码块中的代码时，该常量才是可用的。这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量发生冲突。

##### constexpr是C++11新添加的特性

constexpr是C++11新添加的特性，目的是将运算尽量放在编译阶段，而不是运行阶段。constexpr可以修饰变量、函数、结构体等，使它们可以在编译时被求值，从而提高运行时的效率。constexpr的使用有一些限制和要求，例如：

- constexpr变量必须是字面类型（LiteralType），并且必须立即初始化，初始化表达式必须是常量表达式。
- constexpr函数必须只包含一个return语句，不能引用非全局常量，不能调用非constexpr函数，不能有虚函数，不能为void类型，不能有前缀操作符（v++）。
- constexpr结构体的构造函数必须满足constexpr函数的要求，结构体的成员变量必须是字面类型。



```cpp
// 用constexpr修饰一个变量，表示该变量是一个编译时常量
constexpr int x = 10; // OK
constexpr int y = x + 5; // OK
constexpr int z = y * 2; // OK

// 用constexpr修饰一个函数，表示该函数可以在编译时被求值
constexpr int square(int n) {
    return n * n; // 只能包含一个return语句
}

constexpr int a = square(3); // OK，a的值在编译时就被计算为9
int b = 4;
int c = square(b); // OK，但是c的值在运行时才被计算
constexpr int d = square(b); // 错误，b不是一个常量表达式

// 用constexpr修饰一个结构体，表示该结构体可以在编译时被实例化
struct Point {
    int x, y;
    constexpr Point(int x, int y) : x(x), y(y) {} // 构造函数必须是constexpr
    constexpr int dist() { return x * x + y * y; } // 成员函数也可以是constexpr
};

constexpr Point p(3, 4); // OK，p是一个编译时常量
constexpr int e = p.dist(); // OK，e的值在编译时就被计算为25
```

既然可以选择使用全局变量或局部变量，那么到底应使用哪种呢？首先，全局变量很有吸引力——因为所有的函数能访问全局变量，因此不用传递参数。但易于访问的代价很大——程序不可靠。

而，全局变量也有它们的用处。例如，可以让多个函数可以使用同一个数据块（如月份名数组或原子量数组）。外部存储尤其适于表示常量数据，因为这样可以使用关键字const来防止数据被修改。



另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化。以后再调用函数时，将不会像自动变量那样再次被初始化。



#### 

##### 关键字volatile

表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。听起来似乎很神秘，实际上并非如此。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件（而不是程序）可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。
# cpp-work
用于学习cpp代码
## 类型 内存
#### C++提供了大量的整型,应使用哪种类型呢?
通常, int被设置为对目标计算机而言最为“自然”的长度。
**自然长度(natural size)指的是计算机处理起来效率最高的长度。**如果没有非常有说服力的理由来选择其他类型，则应使用int。
现在来看看可能使用其他类型的原因。如果变量表示的值不可能为负，如文档中的字数,则可以使用无符号类型,这样变量可以表示更大的值。
如果知道变量可能表示的整数值大于16位整数的最大可能值,则使用1ong。即使系统上int为32位,也应这样做。这样,将程序移植到16位系统时,
就不会突然无法正常工作（参见图3.2）。如果要存储的值超过20亿，可使用long long。

#### 内存节省主要是数组这种连续内存结构的数据
如果short比int小,则使用short可以节省内存。通常,仅当有大型整型数组时,才有必要使用short。(数组是一种数据结构,在内存中连续存储同
类型的多个值。)如果节省内存很重要,则应使用short而不是使用int,即使它们的长度是一样的。例如,假设要将程序从int为16位的系统移到int
为32位的系统,则用于存储int数组的内存量将加倍,但short数组不受影响。请记住,节省一点就是赢得一点。


#### 数据的使用说明
C++将整型常量存储为int类型。首先来看看后缀。后缀是放在数字常量后面的字母,用于表示类型。整数后面的1或L后缀表示该整数为long常量, u或U后缀表示unsigned int常量, ul (可以采用任何一种顺序,大写小写均可)表示unsigned long常量(由于小写1看上去像1,因此应使用大写L作后缀)。例如，在int为16位、long为32位的系统上，数字22022被存储为int，占16位，数字22022L被存储为long，占32位。同样，22022LU和22022UL都被存储为unsigned long。 C++11提供了用于表示类型long long的后缀ll和LL,还提供了用于表示类型unsigned long long的后缀ull、Ull、uLL和ULL.接下来考察长度。在C++中，对十进制整数采用的规则，与十六进制和八进制稍微有些不同。对于不带后缀的十进制整数,将使用下面几种类型中能够存储该数的最小类型来表示: int、long或long long。在int为16位、long为32位的计算机系统上, 20000被表示为int类型, 40000被表示为long类型, 3000000000被表示为long long类型。对于不带后缀的十六进制或八进制整数,将使用下面几种类型中能够存储该数的最小类型来表示: int、 unsigned int long、 unsigned long、 long long或unsigned long long。在将40000表示为long的计算机系统中，十六进制数0x9C40 (40000)将被表示为unsigned int。这是因为十六进制常用来表示内存地址,而内存地址是没有符号的,因此, usigned int比long更适合用来表示16位的地址。



#### 数据存储的实质

有趣的是，程序中输入的是M，而不是对应的字符编码77。另外，程序将打印M，而不是77。通过查看内存可以知道, 77是存储在变量ch中的值。这种神奇的力量不是来自char类型,而是来自cin和cout,这些工具为您完成了转换工作。输入时, cin将键盘输入的M转换为77;输出时, cout将值77转换为所显示的字符M; cin和cout的行为都是由变量类型引导的。如果将77存储在int变量中,则cout将把它显示为77 (也就是说, cout显示两个字符7) 。程序清单3.6说明了这一点,该程序还演示了如何在C++中书写字符字面值:将字符用单引号括起,如'M' (注意,示例中没有使用双引号。C++对字符用单引号，对字符串使用双引号。cout对象能够处理这两种情况,但正如第4章将讨论的,这两者有天壤之别) 。最后,程序引入了cout的一项特性—cout. put()函数，该函数显示一个字符。





#### 数据类型提升下面是C++11版本的校验表,编译器将依次查阅该列表。

(1)如果有一个操作数的类型是long double,则将另一个操作数转换为long double。

(2)否则,如果有一个操作数的类型是double,则将另一个操作数转换为double.

(3)否则,如果有一个操作数的类型是float,则将另一个操作数转换为float。

(4)否则,说明操作数都是整型,因此执行整型提升。

(5)在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低,则转换为级别高的类型。

(6)如果一个操作数为有符号的,另一个操作数为无符号的,且无符号操作数的级别比有符号操作数高,则将有符号操作数转换为无符号操作数所属的类型。

(7)否则,如果有符号类型可表示无符号类型的所有可能取值,则将无符号操作数转换为有符号操作数所属的类型。

(8)否则，将两个操作数都转换为有符号类型的无符号版本。ANSI C遵循的规则与ISO 2003 C++相同,这与前述规则稍有不同;而传统K&R C的规则又与ANSI C稍有不同。例如，传统C语言总是将float提升为double，即使两个操作数都是float。

前面的列表谈到了整型级别的概念。简单地说,有符号整型按级别从高到低依次为1ong long、long、 int、 short和signed char。无符号整型的排列顺序与有符号整型相同。类型char、 signed char和unsigned char的级别相同。类型bool的级别最低。wchar_t、char16_t和char32_t的级别与其底层类型相同。



#### 传递参数时的转换
正如第7章将介绍的，传递参数时的类型转换通常由C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short类型（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。



#### 强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。（C++认识到，必须有类型





#### 指针地址

![image-20231109181815368](D:\cpp_work\mdImg\image-20231109181815368.png)

```c++
double *varAddress = &bChar;  //note: 必须以对应的类型来声明 *varAddress的类型，因为*varAddress指的是 double类型的值  varAddress指的是一个变量的引用 

cout << "*varAddress " << *varAddress << endl; // 值
cout << "varAddress " << varAddress << endl; // 地址
```

顺便说一句, *运算符两边的空格是可选的。

传统上,C程序员使用这种格式：

```
int *ptr;
```

这强调\*ptr是一个int类型的值。

而很多C++程序员使用这种格式：

```
int* ptr;
```

这强调的是：int\*是一种类型一指向int的指针。在哪里添加空格对于编译器来说没有任何区别，

您甚至可以这样做：

```
int*ptr;
```

但要知道的是，下面的声明创建一个指针（p1）和一个int变量（p2）：

```
int* p1, p2;
```

对每个指针变量名，都需要使用一个。





**对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。第9章将更详细地讨论这一点。**



##### 数组的指针



**int( * pArrAYInt)[6] = &arrInt; // arrInt是一个int数组**

arrInt 可以看成是数组的第一个元素的地址

arrInt[1]  == *(arrInt + 1)  // 访问第二个元素的值，其实执行的操作是等价的

现在来看一看数组表达式stacks[1]。C++编译器将该表达式看作是*（stacks + 1），这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。最后的结果便是stacks [1]的含义（运算符优先级要求使用括号，如果不使用括号，将给*stacks加1，而不是给stacks加1）。
从该程序的输出可知，*（stacks + 1）和stacks[1]是等价的。同样，*（stacks + 2）和stacks[2]也是等价的。

如果使用的是指针，而不是数组名，则C++也将执行同样的转换

```
arrayname[i] becomes *(arrayname + i)
```

在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。

字符串字面值是常量，这就是为什么代码在声明中使用关键字const的原因。